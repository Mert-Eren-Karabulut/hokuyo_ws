#!/usr/bin/env python3
"""
Reads the output YAML from ptu_lidar_calibrator and converts the
translation and quaternion into a URDF-compatible 'joint' block
with xyz and rpy values.
"""

import yaml
import os
from scipy.spatial.transform import Rotation as R

# --- Configuration ---
# This path matches the 'result_yaml' arg in your calibrate.launch file
DEFAULT_YAML_PATH = os.path.expanduser('~/ptu_lidar_calib.yaml')

# These should match the frames from your calibration
PARENT_LINK = 'tilt_link'
CHILD_LINK = 'laser'
NEW_JOINT_NAME = 'hokuyo_joint_calibrated'
# --- End Configuration ---

def main(yaml_path):
    """
    Reads the specified YAML file, performs conversion, and prints the URDF block.
    """
    print(f"--- Reading calibration from: {yaml_path} ---")
    
    try:
        with open(yaml_path, 'r') as f:
            data = yaml.safe_load(f)
    except FileNotFoundError:
        print(f"ERROR: YAML file not found at {yaml_path}")
        print("Please run the 'Solve' step in the web UI first.")
        return
    except Exception as e:
        print(f"ERROR: Could not read or parse YAML file: {e}")
        return

    try:
        # Extract data from the YAML
        calib_data = data['calibrated_transform']
        t = calib_data['translation']         # List [x, y, z]
        q_xyzw = calib_data['rotation_xyzw'] # List [x, y, z, w]
        
        parent = calib_data.get('parent_frame', PARENT_LINK)
        child = calib_data.get('child_frame', CHILD_LINK)

        if parent != PARENT_LINK or child != CHILD_LINK:
            print(f"Warning: YAML frames ({parent} -> {child}) do not match script configuration.")

    except KeyError as e:
        print(f"ERROR: YAML file is missing expected key: {e}")
        print("Did the calibration save correctly?")
        return
    except Exception as e:
        print(f"ERROR: {e}")
        return

    # --- 1. Format Translation ---
    # Format to 8 decimal places, space-separated
    xyz_str = " ".join([f"{v:.8f}" for v in t])

    # --- 2. Perform Rotation Conversion ---
    try:
        # scipy.spatial.transform.Rotation
        # from_quat expects [x, y, z, w], which is what our YAML provides
        r = R.from_quat(q_xyzw)
    except Exception as e:
        print(f"ERROR during quaternion conversion: {e}")
        print(f"Input quaternion: {q_xyzw}")
        return

    # Convert to RPY (Roll, Pitch, Yaw)
    # URDF 'rpy' is an extrinsic rotation sequence: X (roll), then Y (pitch), then Z (yaw).
    # In scipy, this is represented by 'XYZ' (uppercase).
    rpy_rad = r.as_euler('XYZ', degrees=False)
    rpy_str = " ".join([f"{v:.8f}" for v in rpy_rad])

    # --- 3. Print the Resulting URDF Block ---
    print("\n--- Copy and paste this block into your .urdf file ---")
    print(f"(This replaces 'hokuyo_base' link, 'hokuyo_base_joint', and 'hokuyo_joint')\n")
    
    xml_output = f"""
    <!-- Calibrated transform from {parent} to {child} -->
    <!-- This block was auto-generated by converter.py -->
    <joint name="{NEW_JOINT_NAME}" type="fixed">
        <origin xyz="{xyz_str}" 
                rpy="{rpy_str}" />
        <parent link="{parent}" />
        <child link="{child}" />
        <dynamics damping="1.0" />
    </joint>
"""
    print(xml_output)
    print("---------------------------------------------------------")

if __name__ == "__main__":
    # Allow passing a different path as an argument, 
    # but default to the one from your launch file.
    import sys
    if len(sys.argv) > 1:
        main(sys.argv[1])
    else:
        main(DEFAULT_YAML_PATH)